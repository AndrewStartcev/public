/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ (function() {

eval("// Получаем все элементы с классом menu-item-has-children\r\nconst menuItemsWithChildren = document.querySelectorAll('.menu-item-has-children');\r\n\r\n// Добавляем обработчик событий для каждого элемента\r\nmenuItemsWithChildren.forEach(item => {\r\n  let timeoutEnter;\r\n  let timeoutLeave;\r\n\r\n  // Наведение на элемент\r\n  item.addEventListener('mouseenter', () => {\r\n    clearTimeout(timeoutLeave); // Очищаем задержку ухода, если она есть\r\n    timeoutEnter = setTimeout(() => {\r\n      item.classList.add('menu-show');\r\n    }, 300);\r\n  });\r\n\r\n  // Уход с элемента\r\n  item.addEventListener('mouseleave', () => {\r\n    clearTimeout(timeoutEnter); // Очищаем задержку наведения, если она есть\r\n    timeoutLeave = setTimeout(() => {\r\n      item.classList.remove('menu-show');\r\n    }, 300);\r\n  });\r\n\r\n  item.addEventListener('click', (event) => {\r\n    if (!event.target.closest('.sub-menu')) {\r\n      item.classList.toggle('menu-show');\r\n    }\r\n  });\r\n\r\n  // Добавим обработчик для .sub-menu, чтобы предотвратить всплытие события\r\n  document.querySelector('.sub-menu').addEventListener('click', (event) => {\r\n    event.stopPropagation();\r\n  });\r\n});\r\n\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n  // Получаем кнопки и элемент меню\r\n  const burger = document.querySelector('.burger');\r\n  const headerPopupMenu = document.querySelector('.header');\r\n  const headerPopupMenuContent = document.querySelector('.header__bottom');\r\n\r\n  // Добавляем обработчик события для открытия\r\n  burger.addEventListener('click', function () {\r\n    headerPopupMenuContent.classList.toggle('show');\r\n    burger.classList.toggle('burger-close');\r\n  });\r\n\r\n  // Добавляем обработчик события для клика вне элемента\r\n  document.addEventListener('click', function (event) {\r\n    if (!headerPopupMenuContent.contains(event.target) && !burger.contains(event.target)) {\r\n      headerPopupMenuContent.classList.remove('show');\r\n      burger.classList.remove('burger-close')\r\n    }\r\n  });\r\n\r\n  // Добавляем обработчик события для клавиши Esc\r\n  document.addEventListener('keydown', function (event) {\r\n    if (event.key === 'Escape') {\r\n      headerPopupMenuContent.classList.remove('show');\r\n      burger.classList.remove('burger-close')\r\n    }\r\n  });\r\n});\r\n\r\n\r\nconst mainSlider = new Swiper('#MainSlider', {\r\n  speed: 400,\r\n  spaceBetween: 100,\r\n  loop: true,\r\n  autoplay: {\r\n    delay: 5000,\r\n  },\r\n  pagination: {\r\n    el: '.main-hero__pagination',\r\n    type: 'bullets',\r\n  },\r\n});\r\n\r\n\r\nconst mainReview = new Swiper('#MainReview', {\r\n  speed: 400,\r\n  spaceBetween: 10,\r\n  slidesPerView: 1,\r\n  loop: true,\r\n  autoplay: {\r\n    delay: 5000,\r\n  },\r\n  breakpoints: {\r\n    660: {\r\n      slidesPerView: 2,\r\n      spaceBetween: 20\r\n    },\r\n    1024: {\r\n      slidesPerView: 3,\r\n      spaceBetween: 30\r\n    }\r\n  }\r\n});\r\n\r\n\r\nconst accordionHeaders = document.querySelectorAll('.accordion-header');\r\n\r\naccordionHeaders.forEach(header => {\r\n  header.addEventListener('click', () => {\r\n    const accordionItem = header.parentElement;\r\n    const accordionBody = header.nextElementSibling;\r\n\r\n    accordionItem.classList.toggle('active');\r\n\r\n    if (accordionItem.classList.contains('active')) {\r\n      accordionBody.style.maxHeight = '100%';\r\n      accordionBody.style.display = 'block';\r\n    } else {\r\n      accordionBody.style.maxHeight = null;\r\n      accordionBody.style.display = 'none';\r\n    }\r\n\r\n    accordionHeaders.forEach(otherHeader => {\r\n      if (otherHeader !== header) {\r\n        const otherItem = otherHeader.parentElement;\r\n        otherItem.classList.remove('active');\r\n\r\n        otherItem.querySelector('.accordion-body').style.maxHeight = null;\r\n        otherItem.querySelector('.accordion-body').style.display = 'none';\r\n      }\r\n    });\r\n  });\r\n});\r\n\r\n\r\n\r\n\r\n\r\n/*==========================================================================================================================================================================*/\r\n/* Динамический Адаптив */\r\nfunction dynamicAdapt(type) {\r\n  this.type = type;\r\n}\r\n\r\n\r\n// Функция адаптива:\r\ndynamicAdapt.prototype.init = function () {\r\n  const _this = this;\r\n  this.оbjects = [];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Массив объектов.\r\n  this.daClassname = \"_dynamic_adapt_\";\r\n  this.nodes = document.querySelectorAll(\"[data-da]\");\t\t\t\t\t\t\t\t\t\t\t// Массив DOM-элементов.\r\n  for (let i = 0; i < this.nodes.length; i++) {\t\t\t\t\t\t\t\t\t\t\t\t\t// Наполнение оbjects объектами.\r\n    const node = this.nodes[i];\r\n    const data = node.dataset.da.trim();\r\n    const dataArray = data.split(\",\");\r\n    const оbject = {};\r\n    оbject.element = node;\r\n    оbject.parent = node.parentNode;\r\n    оbject.destination = document.querySelector(dataArray[0].trim());\r\n    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : \"47.99\";\r\n    оbject.place = dataArray[2] ? dataArray[2].trim() : \"last\";\r\n    оbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n    this.оbjects.push(оbject);\r\n  }\r\n  this.arraySort(this.оbjects);\r\n  this.mediaQueries = Array.prototype.map.call(this.оbjects, function (item) {\t\t\t\t\t// Массив уникальных медиа-запросов.\r\n    return \"(\" + this.type + \"-width: \" + item.breakpoint + \"px),\" + item.breakpoint;\r\n  }, this);\r\n  this.mediaQueries = Array.prototype.filter.call(this.mediaQueries, function (item, index, self) {\r\n    return Array.prototype.indexOf.call(self, item) === index;\r\n  });\r\n  for (let i = 0; i < this.mediaQueries.length; i++) {\t\t\t\t\t\t\t\t\t\t\t// Навешивание слушателя на медиа-запрос и вызов обработчика\r\n    const media = this.mediaQueries[i];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// при первом запуске.\r\n    const mediaSplit = String.prototype.split.call(media, \",\");\r\n    const matchMedia = window.matchMedia(mediaSplit[0]);\r\n    const mediaBreakpoint = mediaSplit[1];\r\n    const оbjectsFilter = Array.prototype.filter.call(this.оbjects, function (item) {\t\t\t// Массив объектов с подходящим брейкпоинтом.\r\n      return item.breakpoint === mediaBreakpoint;\r\n    });\r\n    matchMedia.addListener(function () {\r\n      _this.mediaHandler(matchMedia, оbjectsFilter);\r\n    });\r\n    this.mediaHandler(matchMedia, оbjectsFilter);\r\n  }\r\n};\r\n\r\n\r\n// Функция перемещения:\r\ndynamicAdapt.prototype.mediaHandler = function (matchMedia, оbjects) {\r\n  if (matchMedia.matches) {\r\n    for (let i = 0; i < оbjects.length; i++) {\r\n      const оbject = оbjects[i];\r\n      оbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n      this.moveTo(оbject.place, оbject.element, оbject.destination);\r\n    }\r\n  } else {\r\n    for (let i = 0; i < оbjects.length; i++) {\r\n      const оbject = оbjects[i];\r\n      if (оbject.element.classList.contains(this.daClassname)) {\r\n        this.moveBack(оbject.parent, оbject.element, оbject.index);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n// Функция перемещения:\r\ndynamicAdapt.prototype.moveTo = function (place, element, destination) {\r\n  element.classList.add(this.daClassname);\r\n  if (place === \"last\" || place >= destination.children.length) {\r\n    destination.insertAdjacentElement(\"beforeend\", element);\r\n    return;\r\n  }\r\n  if (place === \"first\") {\r\n    destination.insertAdjacentElement(\"afterbegin\", element);\r\n    return;\r\n  }\r\n  destination.children[place].insertAdjacentElement(\"beforebegin\", element);\r\n}\r\n\r\n\r\n// Функция возврата:\r\ndynamicAdapt.prototype.moveBack = function (parent, element, index) {\r\n  element.classList.remove(this.daClassname);\r\n  if (parent.children[index] !== undefined) {\r\n    parent.children[index].insertAdjacentElement(\"beforebegin\", element);\r\n  } else {\r\n    parent.insertAdjacentElement(\"beforeend\", element);\r\n  }\r\n}\r\n\r\n\r\n// Функция получения индекса внутри родителя:\r\ndynamicAdapt.prototype.indexInParent = function (parent, element) {\r\n  const array = Array.prototype.slice.call(parent.children);\r\n  return Array.prototype.indexOf.call(array, element);\r\n};\r\n\r\n\r\n// Функция сортировки массива по breakpoint и place по возрастанию для this.type = min по убыванию для this.type = max:\r\ndynamicAdapt.prototype.arraySort = function (arr) {\r\n  if (this.type === \"min\") {\r\n    Array.prototype.sort.call(arr, function (a, b) {\r\n      if (a.breakpoint === b.breakpoint) {\r\n        if (a.place === b.place) {\r\n          return 0;\r\n        }\r\n        if (a.place === \"first\" || b.place === \"last\") {\r\n          return -1;\r\n        }\r\n        if (a.place === \"last\" || b.place === \"first\") {\r\n          return 1;\r\n        }\r\n        return a.place - b.place;\r\n      }\r\n      return a.breakpoint - b.breakpoint;\r\n    });\r\n  } else {\r\n    Array.prototype.sort.call(arr, function (a, b) {\r\n      if (a.breakpoint === b.breakpoint) {\r\n        if (a.place === b.place) {\r\n          return 0;\r\n        }\r\n        if (a.place === \"first\" || b.place === \"last\") {\r\n          return 1;\r\n        }\r\n        if (a.place === \"last\" || b.place === \"first\") {\r\n          return -1;\r\n        }\r\n        return b.place - a.place;\r\n      }\r\n      return b.breakpoint - a.breakpoint;\r\n    });\r\n    return;\r\n  }\r\n};\r\nconst da = new dynamicAdapt(\"max\");\r\nda.init();\r\n// data-da=\".info-about,53.125,3\"\r\n\n\n//# sourceURL=webpack://gulp-starter/./src/js/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/main.js"]();
/******/ 	
/******/ })()
;